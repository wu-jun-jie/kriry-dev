# 结构体字节对齐

接下来我们学习的C中的第三种空间-结构体空间，结构体空间是将基本数据类型或者是其它构造数据类型打包的工具。打包就是结构体最主要的一种功能，在打包过程中，我们要引入一个新的概念-字节对齐。这个打包不是随随便便就OK的，不像我们装行李只要全部装进去就好了。

首先我们先来看一段代码，我们将一个结构体里面包含了一个char和int类型，然后声明一个结构体变量，这个变量在内存中占的大小会是1+4吗？

```c
#include <stdio.h>

struct Test{
  	char a;
  	int b;
};

int main(){
  	struct Test test;
  	printf("the test is %lu\n", sizeof(test));
}
```

我们通过sizeof函数查看结构体变量的大小，运行结果如下：这个结构体变量占了8个字节。

```
the test is 8
```

为了提高CPU的效率，我们采用空间的牺牲，来提高CPU运行的效率。对于32位操作系统来说，CPU一次最多操作四个字节的数据，如果我们按照左边的方式，char类型紧挨着int类型，它们的确只需要五个字节，但是CPU读取内存的时候为了提高效率，只会四个字节一起读，就将int类型的数据读取了，这个时候就需要经过运算取出char的值，读取int类型的值呐？由于int类型的值被上次读取了三个字节，所以依然需要再读取一次，然后再运算。如果CPU在第二次读取的时候指针改变位置，经过计算从int类型的第一个字节读取，这样CPU的效率依旧会下降。所以为了提高效率，结构体如右边存储，char和int类型之间相隔了三个字节，这样读取之后就是一个完整的数据类型而不需要通过运算来提高了效率，虽然这样牺牲了三个字节的空间。这样的解决方案我们就叫做字节对齐。32位对齐是大多数系统默认的情况。

![6.png](http://www.maiziedu.com/uploads/new_img/XSHmYMMThahvRfd1W5.png)

通过前面对结构体字节的介绍，我们已经知道结构体变量的大小是默认对齐大小的倍数。32位系统的结构体变量大小就是4的倍数个字节。现在我们创建了两个结构体，它们的基本变量一致，只是变量的顺序不一致，而两个结构体变量的大小之比是8:12。

我们可以从右图看出，abc这个结构体发现char首先申请了四个字节，然后发现short可以存储在char未使用的三个字节中，最后就是int类型，最终这个结构体变量使用了8个字节。下面的是my这个结构体，首先为char分配四个字节，由于int类型只能单独分配，最后再为short分配四个字节的空间，所以总共是12个字节的空间。

![7.png](http://www.maiziedu.com/uploads/new_img/3tFpqYTAq5BZUp8O2S.png)