# 运算符标签操作

## 指针运算符加减标签操作

指针作为一种特殊的变量，它的运算和普通变量是有一定区别的。指针在运算中并没有具备其它变量所有的性能。我们只是给大家介绍一些指针常用的运算：

加法运算(+,++)

我们知道一个整型的变量可以为它做加法运算，那么指针变量加1之后是一个地址还是一个整型？

```c
int *p=xxx； [0x12] //有一个int类型的指针，它的指针变量存储的地址为0x12。
p=p+1；
```

由于p是指针变量，而1是整型变量，加法操作会将指针优先级作为最高优先级。我们不会得到0x13这个值，而是0x12+1*(sizeof(*p))，它这里不是将指针向下挪动一个字节，而是一个int类型的字节，也就是四个字节。所以指针的加法操作是对移动单位的加法，单位的大小是指针类型的大小。

减法操作(-,--)

减法操作和加法操作是一样的，只是指针移动的方向不一样，但是它们都是针对指针类型这个单位来移动的。

下标运算符[]

[n]，n被称为标签，这种访问方式就是地址内容的标签访问方式。我们有时候也许并不希望按照加法操作来依次的读取内存空间，而希望一个跳跃式的读取。C帮我们在内存中做了一个标记，它将指针指向的内存地址标记为0，然后按照一个单位的大小向下移动，依次标号。我们就可以通过p[2]直接访问那一个内存地址。实际上p+n只是将指针向后移动，是对指针变量的地址进行操作。而p[n]是移动了之后还可以直接对内容进行操作。*(p+n)=p[n];

![0.png](http://www.maiziedu.com/uploads/new_img/S7gS8JZTkNRS3vEnYR.png)

### 指针运算符加减举例

测试代码如下

首先定义了两个十六进制的int类型的变量，将变量b的地址赋给了p1，将b的变量中的四个字节取小地址的字节（指向99的字节）赋给了char类型的指针p2，我们前面在进行不同类型的赋值的时候是有警告的，有些编译器直接会报错，编译通不过的。这里我们进行了强制类型的转换，就告诉了编译器，这个不同类型的赋值我们作为程序员是故意而为之的，编译器就不会再对这里报错了。

![1.png](http://www.maiziedu.com/uploads/new_img/qSYK2HohMBZ3ZsypUB.png)

运行结果如下

如果我们对*p1进行输出，结果应该是99991199，但是我们对*(p1+1)和p1[1]进行输出的时候，结果却是a变量的值。我们可以想到指针变量p1的地址向后移动了一个int类型的字节数（关于两个变量在内存中的存储方向在编译原理中会讲到），就到了a变量的地址。至于*p1+1就是将p1指向的值99991199取出来再加一，显然结果也是正确的。在第一个章节的时候，我们就知道一个int类型四个字节的存储方式，它指向的是0x99（末尾不是开头），再移动一个就是存储的0x11，显然结果是正确的。

![2.png](http://www.maiziedu.com/uploads/new_img/N9LNqpSxuofrEPb6Jn.png)

通过这个例子，我们明白了指针的加减运算就是地址的偏移，指针变量的类型决定一个单位的偏移大小。C语言强大的指针访问功能可以将整个内存切割成许多的标签，你可以通过一个指针访问到整个内存，比如p[10000]，虽然这已经是越界访问了。如果我们知道某一个内存地址里面存放的是你在玩游戏时的角色的血量，你通过指针去修改这个值变为很大，那你就在游戏中无敌了。从语法角度来讲，越界是允许的，C语言不会关心你越界的问题，C的目的就是将内存标签化。但是我们作为程序员，使用指针的标签访问的时候一定要考虑它的范围大小。这也是后面我们在讲到内存分配和函数调用的时候的要介绍的，定义指针的时候我们就需要定义它的重要的属性-大小。没有大小我们就可以任意访问，任意访问就可能出现系统内存泄漏。

当我们将上面的p1[1]改成p1[10000]，编译的时候没有报错，但是运行的时候就报出了一个段错误；p1[1]改成p1[100]之后，读取了一个值，显然这个内存是可以可读取的。这就是指针越界访问的强大。

### 指针逻辑运算符操作

指针变量存储的是一个地址，可以将它理解成一个数值。只是编译器会因为它是一个指针类型而将它读取作为一个地址。逻辑运算符包括>=,<=,==,!=；显然我们比较两个地址的数值的大小是没有意义的。

指针中最常用的逻辑操作符==,!=这两个是最常用的。

我们将0x0规定为地址的无效值，结束标志。NULL就是一个在C编译器中一个被定义好了的宏，它代表了这个无效地址。我们经常使用p==NULL或者是p！=NULL来判断指针是否是可用的。

指针必须是同类型的比较才有意义。

指针变量虽然它们都是一个地址数值，但是它们也要是同一种类型的指针变量才可以进行比较。这个不同类型的比较编译器是会报错的。我们可以对传来的指针进行类型的检测，通过比较来查看编译器的报错得知指针类型。

测试代码如下：

![7.png](http://www.maiziedu.com/uploads/new_img/4lJ3VgLZnanrxStUJ8.png)

运行结果如下

我们将一个char和int类型的指针进行比较，编译器只是报了一个类型不匹配警告。如果我们在开发过程中，将编译器的警告选项再降低的话就可能是报错了。

![8.png](http://www.maiziedu.com/uploads/new_img/cPSTAk5bbbqw7JFfA1.png)