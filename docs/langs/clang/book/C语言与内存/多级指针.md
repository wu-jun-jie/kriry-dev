# 多级指针

我们将指针变量理解为一个存储地址的变量。如果这个地址里面存储的依然是地址，那么我们就可以定义一个二维指针。通过一个二维指针，我们通过两次寻址操作就可以找到这个值。

比如我们定义一个`int **p；`这是一个二维指针，当编译器看到*p的时候，它知道这是一个指针变量，指向一个地址；当它看到第二个*的时候，它知道指向的地址里面依然还是地址。如下图所示：

![9.png](http://www.maiziedu.com/uploads/new_img/QYJ5SYbClodjVKBug4.png)

如果我们将p[0]和p[1]分别指向两个字符串的空间，两个字符串的空间位置可以是任意的。我们可以将p[0]和p[1]可以描述为一个线性关系，通过两个连续的指针地址，将两块任意的字符串连续，使它们可以通过标签访问。所以二维指针更多的时候是描述内存与内存之间的线性关系。

![90.png](http://www.maiziedu.com/uploads/new_img/ssQaUQChc6zJn8aVBw.png)

二维指针的数据类型和一维指针的数据类型的定义方法是一样的，通过两次寻址就能找到指针的指向的数据。  假如我们定义了`int **p；`我们通过p[0],p[1]……p[n]可以访问到不同的门牌号，它们是一个线性关系。我们规定p[m]==NULL，这个二维空间就结束了。

### 多级指针举例

可能很多同学都执行过这个命令，ping www.baidu.com或者是ping www.qq.com，ping是一个命令，后面的网址就是它的传入参数。不同的参数会导致不同的运行结果。

下面就是我们main函数的标准写法，argc就是传入参数的个数，argv是一个字符串类型的二维指针。当我们需要传递下面四个字符串给main函数的时候，这四个是字符串的首地址不是连续的，我们就可以使用二维指针将它们的首地址存储在连续的空间中。这样我们就可以通过指针变量标签访问的方法访问到这几个字符串。

![91.png](http://www.maiziedu.com/uploads/new_img/GLvDlU2C5JMi7vHXuc.png)

![92.png](http://www.maiziedu.com/uploads/new_img/qhYABwEVWmvvjKnWMA.png)

测试代码如下

我们使用for循环来遍历所有的参数，并使用指针的标签访问它的所有参数，这里的标签地址是连续的，尽管字符串存储的地址是不相关的，但是通过二维指针，它们的首地址构成了一个线性的关系。

![93.png](http://www.maiziedu.com/uploads/new_img/spY6J8CkvDIaJq4uxF.png)

运行结果如下

可以看到我们为main函数传入的参数不同，但是通过指针的标签访问方式来看，存储这些字符串的首地址的指针空间是连续的。当编译器接收到四个参数，先找出四个地址存储这些字符串，然后找到四个连续的地址依次存储它们的首地址，最后将四个连续地址的首地址赋给argv。

![94.png](http://www.maiziedu.com/uploads/new_img/da22SG6gqBNwJUBFLW.png)

![95.png](http://www.maiziedu.com/uploads/new_img/WpKhKO5adcKeaZLcw8.png)  

如果我们不知道参数的个数，不使用argc这个参数，我们怎么遍历所有的字符串参数呐？

测试代码如下

我们前面已经提到过NULL是一个结束的标志，所以这里我们知道的是参数的首地址argv[0]，却不知道它的结束在哪，我们不能一直通过循环读取，那样会造成指针越界的错误，所以使用NULL判断结束。如果你以后看到二维指针，就很有可能看到这个while循环的模板，因为这是一个操作二维指针很常用的例子。

![96.png](http://www.maiziedu.com/uploads/new_img/5e1Q3kkFn1C98oTdMN.png)

运行结果如下

可以看到通过不知道参数个数的方法，我们也对它的所有参数进行遍历输出了。这里的递增是连续地址的地址的递增。

![97.png](http://www.maiziedu.com/uploads/new_img/nUtlZFxMVpsDTuqgiN.png)

对于二维指针，它实际上是一张地址表，这个地址表是无穷大的，通过编译器定义的NULL，我们知道了这个二维指针结束的标志。在我们的实际开发中，我们最多能用到二维指针，三维指针都使用不到了。二维指针已经能够很好的表达我们的逻辑，别的程序员也能够看懂我们对这个问题的解决方案是怎样的。